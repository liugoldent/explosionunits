---
{
  "title": "1. 設計模式分類",
  "lang": "zH",
  "description": "在這篇，主要先介紹設計模式的分類",
  "meta": [{"name":"keywords", "content":"Design Pattern, 設計模式"}],
  "tags": ['JavaScript'],
  "sidebarDepth": "3"
}
---
# 設計模式分類
![DesignPattern](https://i.imgur.com/ULiS96A.png)
## 生成模式（Creational Patterns）

### Abstract Factory
以同一個介面來建立一整族相關或相依的物件，不需點名各物件真正所屬的具象類別

### Builder
從複雜物件的佈局中抽取出生成程序，以便用同一個生成程序製造各種不同的物件佈局

### Factory Method
定義可資生成物件的介面，但讓子類別去決定該具現出哪一種類別的物件。此模式讓類別將具現化程序交付給子類別去處置。

### Prototype
制定可用原型個體生成的物件類型，爾後只需複製此原型即可生成新物件。

### Singleton
確保類別只會有一個物件實體存在，並提供單一存取窗口

## 結構模式（Structural Patterns）

### Adapter
將類別的介面轉換成外界所預期的另一種介面，讓原先介面不相容的問題而無法協力合作的類別能放在一起用

### Bridge
將實作體系與抽象體系分離開來，讓兩者能各自更動各自演進。

### Composite
將物件組織成樹狀結構、「部分 — 全體」層級關係，讓外界以一致性的方式對待個別物件和整體物件

### Decorator
將額外權責動態附加於物件身上，不必衍生子類別及可彈性擴增功能。

### Facade
替子系統裡一堆介面定義一套統一的高階介面，讓子系統更容易使用

### Flyweight
以共享機制有效地支援一大堆小規模的物件

### Proxy
替其他物件預留代理者空位，藉此控制存取其他物件。

## 行為模式（Behavioral Patterns）

### Chain of Responsibility
讓多個物件都有機會處理某一個訊息，以降低訊息發送者和接收者之間的耦合關係。它將接收者物件串連起來，讓訊息流經其中，直到被處理了為止。

### Command
將訊息封裝成物件，以便能用各種不同訊息、暫佇、紀錄、復原等方式加以參數化處理

### Interpreter
針對標的語言定義出文法，以及可以解讀這種語句的編譯器

### Iterator
不需知曉聚合物件的內部細節，即可依序存取內含的每一個元素

### Mediator
定義可將一群物件互動方式封裝起來的物件。因為物件彼此不直接相互指涉，所以耦合性低，容易逐一變更互動關係。

### Memento
在不違反封裝性的前提下，捕捉物件的內部狀態並存在外面，以便日後回復至同一狀態。

### Observer
定義一對多的物件依存關係，讓物件狀態一有變動，就自動通知其他相依物件做該做的更新動作。

### State
讓物件的外顯行為隨內部狀態的改變而改變，彷彿連類別也改變似的

### Strategy-策略模式x
定義一整族的演算法，將每一個演算法封裝起來，可交換使用，更可在不影響外界的情況下個別抽換所使用的演算法

### Template Methods
對於操作只先定義好演算法的輪廓，某些步驟則留給子類別去填補，以便在不改變演算法整體構造的情況下讓子類別去精煉某些步驟。

### Visitor
定義能逐一施行於物件結構裡各個元素的操作，讓你不必修改作用物件的類別介面，就能定義新的操作。
